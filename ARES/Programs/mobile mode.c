#pragma config(Sensor, dgtl1,  irNorth,             sensorDigitalIn)
#pragma config(Sensor, dgtl2,  irEast,              sensorDigitalIn)
#pragma config(Sensor, dgtl3,  irSouth,             sensorDigitalIn)
#pragma config(Sensor, dgtl4,  irWest,              sensorDigitalIn)
#pragma config(Sensor, dgtl7,  sonarSensor,         sensorSONAR_inch)
#pragma config(Motor,  port4,           fServo,        tmotorServoStandard, openLoop)
#pragma config(Motor,  port6,           blMotor,       tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port7,           brMotor,       tmotorNormal, openLoop)
#pragma config(Motor,  port8,           flMotor,       tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port9,           frMotor,       tmotorNormal, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//digital sensors - four IR direction detectors, ultrasound input and output (inches)
//motor/servo ports - pan and fire servos, four drive motors
//fire servo - negative fires. positive stops firing. see "fire test.c" file

//********************************Global Variables and Constants********************************
typedef enum
{
  North,
  East,
  South,
  West
} IRSensorDirection;

IRSensorDirection curDir = South;
IRSensorDirection lastDir = South;
bool obstacleDetected = false;
bool doFire = false;
int nCount = 0, wCount = 0, eCount = 0, sCount = 0;

//firing constants
const int SERVO_MOVE_TIME = 300;
const int DO_FIRE_SERVO = -40;
const int STOP_FIRE_SERVO = 50;

//main constants
const int NUM_READINGS = 10;
const int ALT_ROUTINE_TIME = 500;
const int NUM_FIRED = 20;

//obstacle constants
const int MINIMUM_DISTANCE = 14;

//movement constants
const int SPEED = 127;
const int TURN_SPEED = 90;
const int REVERSE_TIME = 1500;
const int MOVE_TIME = 200;
const int ALT_ROUTINE_TIME = 500;
const int NUM_FIRED = 20;



//************************************Function Prototypes****************************************
//RobotC does not allow passing arrays!!!!
//RobotC does not allow for pointers... yay global variables!!!!
//  - this is to trim down space taken up by RobotC firmware

//IR Detection Task subroutines
void getInstantDirection();
void setModeDirection();

//Drive Control Task subroutines
void dSpeed( int blSpeed, int brSpeed, int flSpeed, int frSpeed );

//Main subroutines
void endProgram();

//**************************************IR Detection*********************************************
//Four global variables to keep up with instantaneous direction counts
//Get the instantaneous direction reading
//      - method - "getInstantDirection()"
//Increment associated int
//Perform this process NUM_READINGS times
//Determine the mode direction over NUM_READINGS
//      - method - "setModeDirection()
//Update global variables "curDir" and "lastDir"
task IRDetectionTask()
{
  while( true )
  {
    for( int numCount = 0; numCount < NUM_READINGS; numCount++ )
    {
      getInstantDirection();

    }//end while numCount

    setModeDirection();

    nCount = 0; eCount = 0; wCount = 0; sCount = 0;

  }//end while true

}//end irDetectionTask

void getInstantDirection()
{
  if( SensorValue[ irWest ] == 0 )
    wCount++;
  else if( SensorValue[ irEast ] == 0 )
    eCount++;
  else if( SensorValue[ irNorth ] == 0 )
    nCount++;
  else if( SensorValue[ irSouth ] == 0 )
    sCount++;

}//end getInstantDirection

void setModeDirection()
{
  IRSensorDirection maxDir = North;
  int max = nCount;

  //fire if enemy is persistently in front of ARES
  if( nCount == NUM_READINGS )
    doFire = true;

  if( eCount > max )
  {
    maxDir = East;
    max = eCount;
  }//end if
  if( wCount > max )
  {
    maxDir = West;
    max = wCount;
  }//end if
  if( sCount > max )
    maxDir = South;

  lastDir = curDir;
  curDir = maxDir;

}//end setModeDirection

//**************************************Drive Control********************************************
//Respond to global variable "curDir"
//proceed forward or turn left or turn right
/////OR
//Respond to global variable "obstacleDetected"

task DriveTask()
{
  while( true )
  {
    //back up from obstacle and pause to get a new reading
    if( obstacleDetected == true )
    {
        dSpeed( -SPEED, -SPEED, -SPEED, -SPEED ); //reverse
        wait1Msec(REVERSE_TIME);
        dSpeed( 0, 0, 0, 0 ); //stop
        obstacleDetected = false;

    }//end if
    else
    {
      //each pass through this while loop moves far quicker than the robot can physically
      //move so each pass must be halted temporarily to allow the robot to physically move
      wait1Msec(MOVE_TIME);
      switch( curDir )
      {
        case North:
          dSpeed( SPEED, SPEED, SPEED, SPEED ); //forward
          break;
        case East:
          dSpeed( TURN_SPEED, -TURN_SPEED, TURN_SPEED, -TURN_SPEED); //turn right
          break;
        case West:
          dSpeed( -TURN_SPEED, TURN_SPEED, -TURN_SPEED, TURN_SPEED ); //turn left
          break;
        case South:
          if( lastDir == West )
            dSpeed( -TURN_SPEED, TURN_SPEED, -TURN_SPEED, TURN_SPEED ); //turn left
          else dSpeed( TURN_SPEED, -TURN_SPEED, TURN_SPEED, -TURN_SPEED); //turn right
          break;

      }//end switch
    }//end else
  }//end while
}//end driveTask

void dSpeed( int blSpeed, int brSpeed, int flSpeed, int frSpeed )
{
  motor[blMotor] = blSpeed;
  motor[brMotor] = brSpeed;
  motor[flMotor] = flSpeed;
  motor[frMotor] = frSpeed;

}//end dSpeed

//************************************Obstacle Detection*****************************************
//Get reading from ultrasound sensor
//Compare reading to minimum distance
//if two consecutive readings less than MINIMUM_DISTANCE are made update global variable "obstacleDetected"
task UltraSoundTask()
{
  bool obstaclePossible = false;
  int usCount = 0;
  int senVal = 0;

  while( true )
  {
    //sonar will return a -1 if it receives no signal back so low bound of "0" must be set
    //as the sensor gets erroneous readings, i am requiring it to make two readings (in the appropriate range)
    //consecutively before initiating an obstacle avoidance maneuver
    while( usCount < 2 )
    {
      senVal = SensorValue[sonarSensor];
      if( senVal < MINIMUM_DISTANCE && senVal > 0 )
      {
			  if( obstaclePossible == false )
			     obstaclePossible = true;
			  else obstacleDetected = true;

		  }//if senVal

		  usCount++;
		  //allow the next reading to come through since the ultra sound wave takes time to return
	    wait1Msec(1);

	  }//end while

	  obstaclePossible = false;
	  usCount = 0;

	}//while true
}//end ultraSoundTask

//***************************************Main****************************************************
//Initiate Primary Tasks
//Assign Task Priority
//Ends Program when necessary
//determines when to fire gun and alternates between gun and ultrasound
task main()
{
  wait1Msec(3000);
  StartTask(IRDetectionTask);
  StartTask(DriveTask);
  StartTask(UltraSoundTask);
  int fireCount = 0;
  int mainSenVal = 0;

  while( fireCount < NUM_FIRED )
  {
   wait1Msec(1);
   mainSenVal = SensorValue[sonarSensor];
   //robot will only fire if doFire is true and if the sonar is not within two feet of an object
   if( doFire == true && (mainSenVal > 24 || mainSenVal < 0 ) )
   {
    wait1Msec(MOVE_TIME);
    StopTask(UltraSoundTask);
    motor[fServo] = DO_FIRE_SERVO; //fire
    wait1Msec(ALT_ROUTINE_TIME); //wait
    motor[fServo] = STOP_FIRE_SERVO; //stop firing
    wait1Msec( SERVO_MOVE_TIME );
    StartTask(UltraSoundTask);
    fireCount++;
   }//end if
   doFire = false;
   //keep program alive until gun has fired "NUM_FIRED" times

  }//end while

  endProgram();

}//end main

void endProgram()
{
   motor[fServo] = 50; //stop firing
   wait1Msec( SERVO_MOVE_TIME );

   StopAllTasks();

}//endProgram

/******************************************NOTES******************************************************
1/13/2011 - removed avoidObstacle() and faceEnemy() methods as they slowed run time and took up unneeded space
1/13/2011 - removed keepTurretStraight() method as the turret is physically locked in place
1/13/2011 - removed turret and pan servos and turret potentiometer from sensors list as they are not used
1/13/2011 - appropriately set and tested new NUM_READINGS, MOVE_TIME and MINIMUM_DISTANCE but more testing needed
1/13/2011 - SOUTH only turns left to face the target
1/13/2011 - cleared up unneeded and commented out code and updated comments

1/16/2011 - reinstated lastDir variable to smooth South turns
1/16/2011 - need to narrow North IR sensor's field of vision. this should make robot turn much more accurately
1/16/2011 - removed fireTask. gun firing will be part of main
1/16/2011 - robot is fully functional and decently accurate

1/18/2011 - added lastDir == North as another condition for firing. this makes sure the robot is facing the target
1/18/2011 - made one method that receives 4 variables for driving instead of 5 methods for specific turns/stops/etc.

1/20/2011 - changed turning speed so robot doesnt overshoot its target by turning too far
1/20/2011 - fixed error with gun not stopping firing. the servo had to be given time to move
******************************************************************************************************/
